{"componentChunkName":"component---src-templates-post-template-tsx","path":"/230304-1/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>🟡 CSS 정의와 역할</h3>\n<ul>\n<li>Html문서의 스타일을 나타내기 위해 사용하는 언어</li>\n<li>문서의 구조와 스타일을 별도로 분리하여 html의 각 요소를 꾸미는 역할을 한다.</li>\n</ul>\n<br>  \n<h3>🟡 CSS 등장 이전</h3>\n<ul>\n<li>각 태그마다 직접 style로 스타일을 지정해야했음.\n<ul>\n<li>같은 스타일 요소를 여러 페이지에서 중복 사용하면, 하나를 수정할 때마다 모든 요소에 반복 수정 필요.</li>\n<li>Html은 문서구조를 의미하므로, 직접 스타일을 지정하는 것은 바람직하다고 볼 수 없음.</li>\n</ul>\n  <br>  \n</li>\n</ul>\n<h3>🟡 CSS의 문제점</h3>\n<ul>\n<li>모든 CSS는 전역범위를 기준으로 적용되므로, 각기 다른 요소들의 스타일링에 서로 간섭 및 영향을 줄 수 있다.</li>\n<li>CSS파일을 분리하여 저장한 후 연결하여도 각각의 CSS 파일을 읽어들인 html에서는 모든 스타일링이 동일한 범위안에 존재하게 되므로 큰 의미가 없다.</li>\n<li>웹사이트가 점점 복잡하게 제작되면서 유지보수가 용이한 CSS작성이 어려워졌고, 이를 해결하기 위해 <strong>‘CSS방법론’</strong> 이 나오기 시작하였다.</li>\n</ul>\n<br>\n<hr>\n<br/>\n<h3>🟠 OOCSS</h3>\n<ul>\n<li>‘Object Oriected CSS’의 줄임말로 ‘객체지향 CSS’라고도 부를 수 있음.</li>\n<li>Nicole Sullivan(니콜 설리반)이 제창.</li>\n<li>주요 발상\n<ol>\n<li>레고와 같이 자유로운 조합이 가능한 모듈의 집합을 만든다.</li>\n<li>해당 모듈을 조합해 새로운 페이지를 만든다.</li>\n<li>이 경우 신규 페이지 제작시에도 기본적으로 추가적인 CSS를 만들 필요가 없음.</li>\n</ol>\n</li>\n</ul>\n<br/>\n<p><strong>🔸 레고와 같은 모듈을 만들기 위한 2가지 원칙 🔸</strong></p>\n<ol>\n<li>Structure(구조)와 Skin(화면)을 분리한다.\n<ul>\n<li>Structure(구조) : width, height, padding, margin 등이 있다.</li>\n<li>Skin(화면) : color, font, background, box-shadow 등이 있다.</li>\n</ul>\n</li>\n</ol>\n  <br>   \n<ol start=\"2\">\n<li>Container(컨테이너)와 Content(콘텐츠)를 분리한다.\n<ul>\n<li>Container는 ‘영역’, Content는 ‘모듈’</li>\n<li>특정한 콘텐츠는 영역에 지나치게 의존하지 않는다 = 모듈은 가능한 특정한 영역에 의존하지 않도록 한다.</li>\n</ul>\n</li>\n</ol>\n  <br>  \n<p><strong>🔸 결론 🔸</strong></p>\n<ul>\n<li>OOCSS의 역사는 매우 길고, 명확하게 규칙이라 불리는 것도 많지는 않음.</li>\n<li>다른 CSS방법론들도 기본적으로는 OOCSS를 참조하여 개선한 것임.</li>\n<li>현재 OOCSS 한 가지로 CSS설계를 수행하는 것은 현실적이지 않음.</li>\n</ul>\n<br>\n<hr>\n<br>\n<h3>🔵 SMACSS</h3>\n<ul>\n<li>\n<p>‘Scalable and Modular Architecture for CSS’의 줄임말.</p>\n</li>\n<li>\n<p>Jonathan Snook(조나단 스눅)이 제창</p>\n</li>\n<li>\n<p>CSS코드를 각각의 역할에 따라 분류한 것이 특징(base,layout,module,state,theme)</p>\n<p><strong>1. Base(베이스) 규칙</strong></p>\n<ul>\n<li>\n<p>프로젝트의 표준 스타일 정의(배경 색 등 프로젝트 전반에 적용되는 스타일)</p>\n</li>\n<li>\n<p>Reset CSS / Nomalize CSS 적용.</p>\n<p>‣ Reset CSS란?<br>\n- 모든 브라우저의 내장 스타일을 없애는 기법으로, 아무런 스타일이 없는 상태에서 스타일링을 시작하게 됨. <code class=\"language-text\">h1 ~ h6</code>, <code class=\"language-text\">p</code>, <code class=\"language-text\">em</code> 등 각 태그가 가지고 있는 스타일을 모두 없앤다.<br>\n- 각 브라우저 별 버그 발생 가능성이 있으나, 업데이트 불필요.</p>\n<p>‣ Nomalize CSS란?<br>\n- 모든 브라우저가 동등한 스타일을 가질 수 있도록 하는 기법. Reset CSS와는 달리 기존 스타일은 유지하며, 브라우저 별 다른 스타일만 수정하는 방식.<br>\n- 브라우저의 업데이트에 따라 새롭게 적용되는 내장스타일이 생길 수 있으므로 꾸준한 버전 업데이트 필요.<br>\n<br></p>\n</li>\n</ul>\n<p><strong>2. Layout(레이아웃) 규칙</strong></p>\n<ul>\n<li>헤더영역, 메인영역, 사이드바, 푸터 등 웹사이트의 레이아웃을 구성하는 큰 module에 관한 규칙.</li>\n<li>일반적인 경우 특정 페이지에서 <strong>한 차례만 사용</strong> 되므로 <strong>id selector</strong> 를 활용한 스타일링을 허용함.</li>\n<li>반복적으로 사용하는 모듈의 경우에는 <strong>class selector</strong>를 이용.</li>\n</ul>\n  <br>  \n<p><strong>3. Module(모듈) 규칙</strong></p>\n<ul>\n<li>Module은 Title, Button, Card, Nav 등 일반적인 UI 컴포넌트를 나타냄.</li>\n<li>모든 Module은 레이아웃 규칙 안에 배치되는 것을 가정한다.</li>\n<li>다른 페이지로 이동하거나 다른 레이아웃에 삽입하더라도 형태가 틀어지거나 달라지지 않고 사용할 수 있어야 함. (= 특정 콘텐츠에 의존하지 않도록 작성해야함.)</li>\n</ul>\n  <br>   \n<p><strong>4. State(상태) 규칙</strong></p>\n<ul>\n<li>기존 스타일을 덮어쓰거나 확장하기 위해 사용한다.</li>\n<li>기존 스타일을 완전히 덮어씌워 State 스타일을 반영하는 것을 기대하기 때문에, 필요한 경우에는 <code class=\"language-text\">!important</code> 사용도 권장함.</li>\n<li>State는 Layout 또는 Module에 할당할 수 있음.</li>\n<li>State규칙에 따른 class이름은 모두 <code class=\"language-text\">is-</code> 접두사를 붙여 표현.</li>\n<li>자바스크립트에 의존</li>\n</ul>\n  <br>  \n<p><strong>5. Theme(테마) 규칙</strong></p>\n<ul>\n<li>사이트 내 레이아웃이나 색상, 텍스트 처리 등을 일정한 규칙에 따라 덮어쓰는 것.</li>\n<li>기존의 다양한 스타일링이 덮어쓰기의 대상. ( ex / 다크모드, 테마컬러 변경 등)</li>\n<li>Theme규칙에 따른 class이름은 모두 <code class=\"language-text\">theme-</code> 접두사를 붙이는 것을 권장.</li>\n</ul>\n</li>\n</ul>\n<p><strong>🔹 결론 🔹</strong></p>\n<ul>\n<li>프로젝트에서 고려해야할 대부분의 CSS규칙을 포함</li>\n<li>각 규칙이 엄격하지 않아 유연하나, 경우에 따라서는 지나치게 유연한 규칙으로 인해 실제 코드의 지침으로 삼기 어려울 수 있음.</li>\n<li>Module규칙에 OOCSS를 적용하거나 BEM규칙을 일부 적용하는 등 다른 CSS 설계기법과 조합하여 사용하는 경우가 많음.</li>\n</ul>\n<br>\n<hr>\n<br>\n<p>출처 : 우아한테크 - 동동의 CSS방법론 👉🏻 <a href=\"https://youtu.be/B70h37mpD74\" target=\"_blank\" rel=\"nofollow\">https://youtu.be/B70h37mpD74</a></p>","frontmatter":{"title":"CSS방법론-1(OOCSS, SMACSS)","summary":"복잡한 웹사이트를 효과적으로 유지보수하기 위한 CSS방법론","date":"2023.03.04.","categories":["Web","Css","Html"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8e8b8","images":{"fallback":{"src":"/static/3f8dca7bceb49b66b8edba0924bcd76b/5e253/defult.png","srcSet":"/static/3f8dca7bceb49b66b8edba0924bcd76b/d7659/defult.png 449w,\n/static/3f8dca7bceb49b66b8edba0924bcd76b/3fdfe/defult.png 898w,\n/static/3f8dca7bceb49b66b8edba0924bcd76b/5e253/defult.png 1795w","sizes":"(min-width: 1795px) 1795px, 100vw"},"sources":[{"srcSet":"/static/3f8dca7bceb49b66b8edba0924bcd76b/78a64/defult.webp 449w,\n/static/3f8dca7bceb49b66b8edba0924bcd76b/c5934/defult.webp 898w,\n/static/3f8dca7bceb49b66b8edba0924bcd76b/def63/defult.webp 1795w","type":"image/webp","sizes":"(min-width: 1795px) 1795px, 100vw"}]},"width":1795,"height":1052}},"publicURL":"/static/3f8dca7bceb49b66b8edba0924bcd76b/defult.png"}}}}]}},"pageContext":{"slug":"/230304-1/"}},"staticQueryHashes":[],"slicesMap":{}}